# 扫盲-2

## 面向对象和面向过程的区别

- 面向过程编程(POP): 面向过程把解决问题的过程拆成一个个方法,通过一个个方法的执行解决问题

- 面向对象编程(OOP): 面向对象会先抽象出对象,然后用对象执行方法的方式解决问题

相比较于 POP,OOP 开发的程序一般具有下面这些优点:

- **易维护**: 由于良好的结构和封装性,OOP 程序通常更容易维护.
- **易复用**:通过继承和多态,OOP 设计使得代码更具复用性,方便扩展功能.
- **易扩展**:模块化设计使得系统扩展变得更加容易和灵活.

POP 的编程方式通常更为简单和直接,适合处理一些较简单的任务

⚠️**注意:**

- POP 和 OOP 的性能差异主要取决于它们的运行机制,而不仅仅是编程范式本身.因此,简单地比较两者的性能是一个常见的误区

- 在选择编程范式时,性能并不是唯一的考虑因素.代码的可维护性、可扩展性和开发效率同样重要

## 对象实体和对象引用

**对象实体**: new 关键字创建,在堆内存中

**对象引用**: 指向对象的实力,在栈内存中

> 对象引用可以指向0个或者1个对象
>
> 对象可以被n个引种指向

### 对象的相等和引用相等的区别

> 对象的相等一般是比较内存中存放的内容是否相等
>
> 引用的相等一般是比较他们指向的地址是否相等(地址相等不代表里面的内容相等)

## 面向对象的三大特点

**封装\继承\多态**

### 封装

封装是指把对象的状态信息(属性)隐藏在对象内部,不允许外部直接访问;但是可以提供一些可以被外部访问的方法来访问或操作属性.

### 继承

继承是指一个类可以派生出新的类,新的类可以继承父类的属性和方法,同时也可以添加自己的属性和方法.

- 子类拥有父类的所有属性和方法(包括私有属性和私有方法),但是父类中的私有属性和私有方法不等你访问,**只是拥有,不代表能够访问**
- 子类可以重写父类的方法
- 子类可以添加自己的属性和方法,即子类可以扩展父类的功能

### 多态

简单理解: 父类的引用指向子类的对象,通过父类的引用可以调用子类的方法,这就是多态.

- 对象类型和引用类型之间具有继承/实现的关系
- 引用类型变量发出的方法调用到底是在那个类中的,需要在程序运行时才能确定
- 多态不能调用只有在子类中存在,父类中不存在的方法
- 如果子类重写了父类的方法,真正执行的是子类重写的方法,如果子类没有重写父类的方法,执行的是父类的方法

## 接口和抽象类有什么区别

**共同点**

- 实例化: 都不能直接实例化,都需要通过子类来实例化后才能创建具体的对象
- 都可以包含抽象方法,子类必须实现这些抽象方法
- 都可以有默认方法和静态方法,可以有常量

**区别**

- 设计目的: 接口的主要目的是约束类的行为,对象实现了某个类就具有对应的行为.抽象类主要目的是为了代码复用,强调的是所属关系.
- 继承和实现: 一个类可以实现多个接口,但是只能继承一个抽象类
- 成员变量: 接口的成员变量只能是 `public static final` 类型的,抽象类的成员变量可以是任意访问权限的,可以在子类中重新定义和赋值.
- 方法: 
  - `Java 8` 之前,接口中的方法默认是`public abstract` , 也就是只能有方法声明. 自`Java 8`起,可以在接口中定义 `default` 方法和 `static`方法. 自 `Java 9 起`, 接口可以包含 `private` 方法.
  - 抽象类可以包含抽象方法和非抽象方法.抽象方法没有方法体,必须在子类中实现.非抽象方法有具体实现,可以直接在抽象类中使用或在子类中重写.

## 深拷贝和浅拷贝

**浅拷贝**: 浅拷贝会在堆上创建一个新的对象,但是新对象的属性和原对象的属性指向的是同一个内存地址,所以如果原对象的属性是引用类型,那么浅拷贝会将引用类型的地址复制一份给新对象,而不是创建一个新的对象.

**深拷贝**: 深拷贝会在堆上创建一个新的对象,并且会递归地复制原对象的所有属性,包括引用类型的属性.

**引用拷贝**: 引用拷贝是指将一个对象的引用赋值给另一个对象,两个对象指向的是同一个内存地址.不会创建新的对象.

## String,StringBuilder,StringBuffer

- **可变性**:
  - `String`是不可变的字符串,一旦创建,就不能被修改.
  - `StringBuilder`和`StringBuffer`都是继承自`AbstractStringBuilder`类的,而`AbstractStringBuilder`类中是使用字符数组来保存的字符串,不过没有使用`final`和`private`关键字修饰,同时还提供了`append`、`insert`、`delete`等方法来修改字符串.
- **线程安全**:
  - `String`中的对象是不可变的,所以是线程安全的.
  - `StringBuilder`和`StringBuffer`的父类`AbstractStringBuilder`中定义了一些字符串的的基本操作的方法.`StringBuffer`对方法加了同步锁或者对调用的方法加了同步锁,所以是线程安全的.`StringBuilder`没有对方法加同步锁,所以不是线程安全的.
- **性能**:
  - `String`的性能相对较低,因为每次对`String`进行操作,都会创建一个新的对象.
  - `StringBuilder`和`StringBuffer`的性能相对较高,因为它们都是在原对象上进行操作,而不是创建新的对象.相同情况下,`StringBuilder`的性能要比`StringBuffer`高10%-15%.

- **三者总结**:
 - 操作少量数据时,使用`String`
 - 操作大量数据时,使用`StringBuilder`
 - 操作多线程数据时,使用`StringBuffer`

## String 为什么是不可变的?

- `String` 被 `final` 关键字修饰,所以它不能被继承,进而避免了子类破坏 `String` 不可变.
- `String` 种存储字符的数组被 `final` 和 `private` 关键字修饰,并且没有提供任何修改字符数组的方法.

**注意**
> Java8中String存储的是字符数组,而Java9中String存储的是字节数组.
```
//Java-8
public final class String implements java.io.Serializable, Comparable<String>, CharSequence {
    private final char value[];
  //...
}
//Java-9
public final class String implements java.io.Serializable,Comparable<String>, CharSequence {
    // @Stable 注解表示变量最多被修改一次,称为“稳定的”.
    @Stable
    private final byte[] value;
}

```
`Java 9` 为何要将 `String` 的底层实现由 `char[]` 改成了 `byte[]` ?
> 新版的 String 其实支持两个编码方案:Latin-1 和 UTF-16.如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符,那就会使用 Latin-1 作为编码方案.Latin-1 编码方案下,byte 占一个字节(8 位),char 占用 2 个字节（16）,byte 相较 char 节省一半的内存空间.
>
>JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符.

## String#equals() 和 Object#equals() 有何区别?
`String` 中的 `equals` 方法是被重写过的，比较的是 `String` 字符串的值是否相等。 `Object` 的 `equals` 方法是比较的对象的内存地址。

## 字符串常量池的作用了解吗?

字符串常量池 是 `JVM` 为了提升性能和减少内存消耗针对字符串(`String` 类)专门开辟的一块区域,主要目的是为了避免字符串的重复创建.
```
// 在字符串常量池中创建字符串对象 ”ab“
// 将字符串对象 ”ab“ 的引用赋值给 aa
String aa = "ab";
// 直接返回字符串常量池中字符串对象 ”ab“，赋值给引用 bb
String bb = "ab";
System.out.println(aa==bb); // true
```