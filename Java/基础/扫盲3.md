# 扫盲-3

## Java异常

``` text
┌─────────────────────────────────────────────────────────────────────────────────────────────┐
│                                     🟦 Throwable                                           │
│                                                                                             │
├─────────────────────────────────────────────────────────────────────────────────────────────┤
│                  ┌──────────────────────────────────────────┬───────────────────────────────┤
│                  ▼                                          ▼                               │
│         ┌───────────────────────┐                  ┌───────────────────────┐                │
│         │       🟩 Exception   │                   │       🟨 Error       │                │
│         └───────────────────────┘                  └───────────────────────┘                │
│                  │                                          │                               │
├──────────────────┼──────────────────────────────────────────┼───────────────────────────────┤
│          ┌───────┴───────┐                                  ▼                               │
│          ▼               ▼                   ┌───────────────────────┐                      │
│ ┌─────────────────┐  ┌────────────────────┐  │  🔶 Error 子类        │                      │
│ │ Checked Exception│ │Unchecked Exception │  │  OutOfMemoryError     │                      │
│ │「编译时需处理」   │ │「运行时抛出」        │  │  StackOverflowError   │                      │
│ └─────────────────┘  └────────────────────┘  │  VirtualMachineError  │                      │
│          │               │                   │  AssertionError       │                      │
│          │               │                   │  IOError              │                      │
├──────────┼───────────────┼──────────────────────────────────────────────────────────────────┤
│          ▼               ▼                                                                  │
│ ┌────────────────────────────────────┐  ┌─────────────────────────────────────────────────┐ │
│ │  🔧 Checked Exception 典型子类     │  │  🔷 Unchecked Exception 典型子类                │ │
│ │  ├─ IOException                    │  │  ├─ ArithmeticException                         │ │
│ │  ├─ ClassNotFoundException         │  │  ├─ ClassCastException                          │ │
│ │  ├─ SQLException                   │  │  ├─ IllegalThreadStateException                 │ │
│ │  └─ FileNotFoundException          │  │  └─ IndexOutOfBoundsException                   │ │
│ └────────────────────────────────────┘  └─────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────────────────────────────┘
```

## Exception和Error有什么区别?

`Java`所有的异常都继承自`Throwable`类,`Exception`和Error都是`Throwable`的子类。

- `Exception`:异常,程序本身可以处理的异常,可以通过`try-catch`语句捕获并处理.`Exception`的子类有`Checked Exception`(编译时需处理)和`Unchecked Exception`(运行时抛出)两种.
- `Error`:错误,属于程序无法处理的异常,不建议通过`try-catch`语句捕获并处理(一般是系统级问题).`Error`的子类有`VirtualMachineError`(虚拟机错误),`StackOverflowError`(栈溢出错误)等.

## Checked Exception和Unchecked Exception有什么区别?

- `Checked Exception`:编译时需处理的异常,必须在代码中显式处理,否则编译错误.例如`IOException`,`SQLException`等.除了`RuntimeException`及其子类,其他的`Exception`子类都是`Checked Exception`.
- `Unchecked Exception`:运行时抛出的异常,不需要在代码中显式处理,如果不处理,程序会在运行时抛出异常.例如`NullPointerException`,`ArrayIndexOutOfBoundsException`等.

## finally 中的代码一定会执行吗?

不一定的,在某些情况下,`finally` 中的代码不会被执行.
```
业务逻辑
try {
    // 业务逻辑
    //终止当前正在运行的Java虚拟机
    System.exit(0);
} catch (Exception e) {
    // 异常处理
} finally {
    // 最终执行的代码
}   
```

**注意**:
不要在 `finally` 语句块中使用 `return`, 当 `try` 语句和 `finally` 语句中都有 `return` 语句时,`try` 语句块中的 `return` 语句会被忽略. 这是因为 `try` 语句中的 `return` 返回值会先被暂存在一个本地变量中, 当执行到 `finally` 语句中的 `return` 之后, 这个本地变量的值就变为了 `finally` 语句中的 return 返回值.

## 泛型

`Java`泛型是`Java SE 1.5`引入的一个新特性,它允许在定义类、接口和方法时使用类型参数,以实现代码的重用和类型安全.

- 泛型类

  泛型类是指在类定义时使用类型参数的类,例如:
    
  ``` java

    //此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
    //在实例化泛型类时，必须指定T的具体类型
    public class Box<T> {
        private T t;
        public void set(T t) {
            this.t = t;
        }
        public T get() {
            return t;
        }
    }
    ```

- 泛型接口

    泛型接口是指在接口定义时使用类型参数的接口,实现泛型接口,可以指定类型也可以不指定类型,例如:

    ``` java
    
    //泛型接口
    public interface Box<T> {
        void set(T t);
        T get();
    }

    //实现泛型接口,不指定类型
    public class BoxImpl<T> implements Box<T> {
        private T t;
        @Override
        public void set(T t) {
            this.t = t;
        }
        @Override
        public T get() {
            return t;
        }
    }

    //实现泛型接口,指定类型
    public class BoxImpl2 implements Box<String> {
        private String t;
        @Override
        public void set(String t) {
            this.t = t;
        }
        @Override
        public String get() {
            return t;
        }
    }
    ```

- 泛型方法

    泛型方法是指在方法定义时使用类型参数的方法,例如:

    ``` java

    public <T> void print(T t) {
        System.out.println(t);
    }
    ```

项目中常见的泛型:

- `List<T>`: 表示一个有序的元素集合,可以包含重复元素.
- `Map<K,V>`: 表示一个键值对的集合,每个键对应一个值.
- `CommonResult<T>`: 表示一个通用的结果类,用于封装方法的执行结果,包含成功标志、消息和数据.

## 反射

`Java 反射`是一种`Java`语言的特性,它允许在运行时动态地获取类的信息,并可以操作类的属性、方法和构造器等.

- 优点
  - 灵活性和动态性: 反射允许程序在运行时动态地获取类的信息,加载类,创建对象,并可以操作其属性、方法和构造器等.显著的提高了程序的灵活性和动态性.
  - 框架开发的基础: 许多`Java`框架(如`Spring`)都使用了反射机制,反射机制为框架的开发提供了基础.
  - 解耦合和通用性: 通过反射可以编写更加通用,高度解耦合的代码,降低模块之间的依赖度.例如通过反射实现的对象拷贝,序列化,Bean工具类等.
- 缺点
  - 性能开销: 反射操作通常比直接调用方法或访问属性要慢,因为反射需要在运行时动态地获取类的信息,并进行方法调用或属性访问.对于大多数框架场景,这种性能损耗通常是可以接受的,或者框架本身会做一些缓存优化.
  - 安全问题: 反射可以绕过`Java`的访问权限检查,如果使用不当,可能会导致安全问题.
  - 代码可读性差: 由于反射操作是在运行时进行的,因此代码的可读性会下降,尤其是在使用反射调用方法或访问属性时.

**应用场景**

我们日常开发中很少会用到反射.但是我们日常用的框架(`Spring`,`Mybatis`)中在底层就大量使用了反射机制.

- `Spring`的依赖注入(`DI`): `Spring`通过反射机制,可以在运行时动态地创建对象,并将对象的依赖关系注入到对象中.
- `Spring`的`AOP`(面向切面编程): `Spring`通过反射机制,可以在运行时动态地创建代理对象,并将横切关注点(如日志、事务等)织入到目标对象中.
- `Spring`的`Bean`工具类: `Spring`提供了`BeanUtils`类,可以通过反射机制,实现对象的拷贝、序列化、反序列化等操作.
- `Mybatis`的`Mapper`接口: `Mybatis`通过反射机制,可以在运行时动态地创建`Mapper`接口的代理对象,并将 SQL 语句映射到方法调用上.

## 注解

`Java`注解是`Java SE 1.5`引入的一个新特性,它允许在代码中添加元数据,用于描述类、方法、字段等的信息.

注解本质是一个继承了`Annotation` 的特殊接口

- 编译期直接扫描: 注解信息在编译期就会被扫描到,并根据注解的元数据,生成相应的代码.
- 运行时反射: 注解信息在运行时可以通过反射机制获取到,并根据注解的元数据,进行相应的处理.

## SPI 

`SPI`(Service Provider Interface) 是`Java`提供的一种服务发现机制,它允许`Java`程序在运行时动态地加载和使用`SPI`服务的实现类.

`SPI`的工作原理如下:

- 定义`SPI`服务接口: 首先,需要定义一个`SPI`服务接口,该接口描述了`SPI`服务的方法和功能.
- 提供`SPI`服务实现类: 然后,在`SPI`服务的实现类中,实现`SPI`服务接口中定义的方法.

## 序列化和反序列化

- 序列化: 序列化是将对象转换为字节流的过程,可以将对象的状态保存到文件或数据库中,或者在网络中传输.
- 反序列化: 反序列化是将字节流转换为对象的过程,可以将保存的对象状态重新加载到内存中.

> 序列化和反序列化的应用场景:
> 
> - 网络通信: 当需要将对象在网络中传输时,可以将对象序列化为字节流,在接收端反序列化字节流为对象.
> - 数据存储: 当需要将对象保存到文件或数据库中时,可以将对象序列化为字节流,在需要时反序列化字节流为对象.
> - 远程方法调用(RPC): 当需要在分布式系统中调用远程方法时,可以将方法的参数对象序列化为字节流,在接收端反序列化字节流为对象,并调用对应的方法.
>
> 常见的序列化和反序列化协议有:
> 
> - `Java`的`Serializable`接口: `Java`提供的`Serializable`接口,可以将对象转换为字节流,并可以将字节流转换为对象.
> - `JSON`(JavaScript Object Notation): `JSON`是一种轻量级的数据交换格式,可以将对象转换为`JSON`字符串,并可以将`JSON`字符串转换为对象.
> - `XML`(eXtensible Markup Language): `XML`是一种标记语言,可以将对象转换为`XML`字符串,并可以将`XML`字符串转换为对象.
> - `Hessian`、`Thrift`、`gRPC`等: 这些是`Java`中常用的序列化和反序列化协议,它们各具特色,适用于不同的场景.

## I/O

`I/O`(Input/Output) 是`Java`中用于处理输入和输出的机制.它允许程序从外部资源(如文件、网络等)读取数据,并将数据写入外部资源.

`Java`中的`I/O`机制主要包括以下几个部分:

- `字节流`: 用于处理二进制数据的流,如`FileInputStream`、`FileOutputStream`等.
- `字符流`: 用于处理文本数据的流,如`FileReader`、`FileWriter`等.

为什么要分字节流和字符流?

- 字节流: 如果我们不知道编码类型的话,使用字节流的过程中很容易出现乱码问题
- 字符流: 字符流是由 Java 虚拟机将字节转换得到的,整个过程相对耗时高

## 语法糖

语法糖是编程语言为了方便开发而提供的一种语法,它隐藏了底层的实现细节,使得代码更加简洁和易读.

例如,`Java`中的泛型、自动装箱/拆箱、`foreach`循环等都是语法糖.

`JVM` 其实并不能识别语法糖,`Java`语法糖要想被`JVM`识别,必须要先被编译器解糖,然后才可以被`JVM`执行.
