# 扫盲-1

## 1. Java SE,Java EE,Java ME

- `Java SE` (标准版) : 通俗理解就是`JDK`+`JVM`+自带`API`的实现.
  - 为`Java EE`提供了基础
  - 主要要用于开发和部署在桌面、服务器、嵌入式环境及实时环境中使用的 Java 应用程序
- `Java EE` (企业版) : 简单理解是它定义了一套规范,具体的实现依赖于各个厂商.
  - 它是以`Java SE`为基础定义的一套规范
  - 主要用于开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序.
- `Java ME` (微型版本) : 了解即可,已经废废已废废
  - 一套专门为嵌入式设备设计的`api`接口规范,比如机顶盒这种程序.
  - 现在很少人用这个了,已经是安卓的时代了,连我们这种小公司好多项目用`Kotlin `,部分项目图省事用`uniapp`了.

## 2. JVM,JDK,JRE

### `JVM`

`Java`虚拟机(`Java  Virtual Machine`)是指运行`Java`字节码的虚拟机.针对不同的操作系统,`JVM`都有对应的特定实现,目的是使用相同的字节码,在各个操作系统都能得到相同的运行结果. **`Java`的字节码和针对不同操作系统的`JVM`实现是`Java`"一次编译,随处可以运行”的关键点".**

`JVM`不是只有一种实现.只要能满足`JVM`的规范,任何公司和个人都可以开发自己特有的`JVM`.

**主流 JVM 实现对比**

| 实现方案       | 核心优势           | 启动速度           | 内存占用           | 运行性能(长期) | 适用场景                |
| ---------- | -------------- | -------------- | -------------- | -------- | ------------------- |
| HotSpot VM | 兼容性强、生态成熟      | 中等             | 中等             | 优秀       | 通用企业应用、大数据框架        |
| GraalVM    | 高性能、AOT 编译、多语言 | (AOT 快,JIT 中等) | (AOT 低,JIT 中等) | 最优       | 云原生、计算密集、多语言        |
| OpenJ9     | 轻量、低内存、快启动     | 快              | 低              | 良好       | 嵌入式、Serverless、边缘计算 |
| JamVM      | 极致轻量           | 较慢(仅解释)        | 极低             | 较弱       | 资源受限嵌入式设备           |
| Azul Zing  | 无停顿 GC、高可用     | 中等             | 较高             | 优秀       | 金融交易、实时系统(商业)       |

### `JRE`

`Java`运行时环境(`Java Runtime Environment`),`JRE`只包含运行`Java`程序所需的环境和类库.

### `JDK`

`Java`开发工具包(`Java Development Kit`),`JDK`是一个功能齐全的`Java`开发工具包,它包含了`JRE`,以及编译器`javac`和其他工具,如`javadoc`(文档生成器)、`jconsole`(监控工具)、`javap`(反编译工具)等,供开发者使用,用于创建和编译`Java`程序.

**关系图**

```
┌───────────────────────────────────────────────────────────────────────────────┐
│                           🟦 JDK (Java 开发工具包)                             │
│  ┌──────────────────────────────────────────────┐  ┌───────────────────────┐  │
│  │                  🟩 JRE (Java 运行时环境)    │   │  🟨 开发工具集        │  │
│  │  ┌─────────────────────────┐  ┌───────────┐  │   │ ├─ javac 源码编译器   │  │
│  │  │  🟧 JVM (Java 虚拟机)   │  │ 核心类库   │  │   │ ├─ javadoc 文档生成器 │  │
│  │  │  「字节码执行/内存管理」  │  │(java.lang/│  │   │ ├─ jdb 调试工具       │  │
│  │  └─────────────────────────┘  │ util等API)│  │   │ ├─ jar 打包工具       │  │
│  │                               └───────────┘  │   │ └─ junit 测试工具     │  │
│  │  ┌─────────────────────────────────────────┐ │   └───────────────────────┘ │
│  │  │  🔧 其他运行时依赖                      │ │                             │
│  │  │  ├─ JIT 即时编译器(热点代码优化)       │ │                             │
│  │  │  ├─ GC 垃圾回收器(自动内存回收)        │ │                             │
│  │  │  ├─ rt.jar 类库归档(核心类库打包)      │ │                             │
│  │  │  └─ 配置文件(jvm.cfg、logging.properties)│ │                             │
│  │  └─────────────────────────────────────────┘ │                              │
│  └─────────────────────────────────────────────┘                               │
└────────────────────────────────────────────────────────────────────────────────┘
```

### 注意

从 **`JDK 9` 2017 年** 发布开始,`Oracle`对`JDK`的打包结构进行了重大调整,核心变化是移除了独立的`JRE`安装包,并通过 **"模块化"(Project Jigsaw)** 重构了`JDK`内部结构,这使得传统意义上 **"`JDK` 包含独立 `JRE`"的关系不再成立,** **也无需单独区分 "开发用 JDK 和 运行用 JRE"** 的安装场景.

在引入了模块系统之后,`JDK`被重新组织成 `94` 个模块. `Java` 应用可以通过新增的 `jlink` 工具,创建出只包含所依赖的 `JDK` 模块的自定义运行时镜像.这样可以极大的减少 `Java` 运行时环境的大小.

用户可以用 `jlink` 根据自己的需求,创建一个更小的 `runtime`(运行时),而不是不管什么应用,都是同样的 `JRE`.定制的、模块化的 `Java` 运行时映像有助于简化 `Java` 应用的部署和节省内存并增强安全性和可维护性.这对于满足现代应用程序架构的需求,如虚拟化、容器化、微服务和云原生开发,是非常重要的.

**JDK 9+ JDK、JRE、JVM 关系示意图**

```
┌─────────────────────────────────────────────────────────────────────────────────────────────┐
│                           🟦 JDK (Java 开发工具包) [JDK 9+]                                 │
│                                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────────────────────┐   │
│  │                     🟩 运行时相关模块(原 JRE 核心能力,现以模块形式内置)              │   │
│  │                                                                                     │   │
│  │  ┌───────────────────────────────────┐  ┌─────────────────────────────────────────┐ │   │
│  │  │          🟧 JVM (Java 虚拟机)      │  │          核心类库模块                    │ │   │
│  │  │       「字节码执行/内存管理」       │  │      (java.base/java.util etc.模块化API) │ │   │
│  │  └───────────────────────────────────┘  └─────────────────────────────────────────┘ │   │
│  │                                                                                     │   │
│  │  ┌─────────────────────────────────────────────────────────────────────────────┐    │   │
│  │  │               🔧 运行时依赖组件(原 JRE 附属能力,模块化整合)                  │   │   │
│  │  │  ├─ JIT 即时编译器(热点代码优化)                                             │   │   │
│  │  │  ├─ GC 垃圾回收器(自动内存回收)                                              │   │   │
│  │  │  ├─ 模块系统(jlink 工具依赖,用于生成定制运行时)                              │   │   │
│  │  │  └─ 配置文件(jvm.cfg、logging.properties etc.)                              │   │   │
│  │  └─────────────────────────────────────────────────────────────────────────────┘    │   │
│  └─────────────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                            │
│  ┌─────────────────────────────────────────────────────────────────────────────────────┐   │
│  │                     🟨 开发工具模块(原 JDK 独有,现与运行时模块分离但同属 JDK)        │   │
│  │                                                                                     │   │
│  │  ├─ javac 源码编译器(编译 .java → .class)                                           │   │
│  │  ├─ javadoc 文档生成器(从源码提取 API 文档)                                          │   │
│  │  ├─ jdb 调试工具(调试 Java 程序)                                                    │   │
│  │  ├─ jlink 定制运行时工具(按需打包模块,生成"迷你 JRE")                                │   │
│  │  └─ jar/jmod 打包工具(打包模块或类文件)                                              │   │
│  └─────────────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                             │
└─────────────────────────────────────────────────────────────────────────────────────────────┘
```

## 3. Java 的字节码

在`Java`中, `JVM`可以理解的代码就叫做字节码(扩展名为.class的文件). JAVA语言通过字节码的方式在一定程度上解决了传统解释型语言执行效率低的问题.同时又保留了解释性语言可以移植的特点.所以JAVA程序运行相对来说是高效的.

```Markdown
┌──────────────────────────────────────────────────────────────────────────┐
│ .java → javac → .class → 类加载器 → 校验器 → 解释器/JIT → 机器码 → 操作系统 │
└──────────────────────────────────────────────────────────────────────────┘
```

我们需要格外注意的是`.class->机器码` 这一步.在这一步 `JVM` 类加载器首先加载字节码文件,然后通过解释器逐行解释执行,这种方式的执行速度会相对比较慢.而且,有些方法和代码块是经常需要被调用的(也就是所谓的热点代码),所以后面引进了 `JIT(Just in Time Compilation`) 编译器,而 `JIT` 属于运行时编译.当 `JIT` 编译器完成第一次编译后,其会将字节码对应的机器码保存下来,下次可以直接使用.而我们知道,机器码的运行效率肯定是高于 `Java 解释器`的.这也解释了我们为什么经常会说 `Java 是编译与解释共存的语言` .

## 4. 为什么说 Java 语言“编译与解释并存”？

可以把高级编程语言按照程序的执行方式分为两种:

- 编译型: 编译型语言会通过编译器把源代码一次性翻译成可被该平台执行的机器码.一般情况下,编译型语言执行速度较快,开发效率低.常见的编译型语言有`C`,`C++`,`Go`,`Rust`等等.
- 解释型: 解释型语言会通过解释器一句一句的将代码解释为机器代码后再执行.解释型语言开发效率比较快,执行速度比较慢.常见的解释型语言有`Python`,`JavaScript`,`PHP`等等.

**为什么说 `Java`语言“编译与解释并存”？**

这是因为`Java`语言既有编译型语言的特征,也具有解释型语言的特征.因为 `Java` 程序要经过先编译,后解释两个步骤,由 `Java`编写的程序需要先经过编译步骤,生成字节码(`.class` 文件),这种字节码必须由 `Java `解释器来解释执行.

## 5. JIT和AOT的特点.

- `JIT`:  `JIT`是为了改善解释语言的效率而发展出的即时编译技术.这种技术混合了编译语言与解释型语言的优点,它像编译语言一样,先把程序源代码编译成字节码.到执行期时,再将字节码直译,之后执行.`Java`就是这种技术的代表产物.
  
  > 可参考美团文章 
  > 
  > - [基本功 | Java即时编译器原理解析及实践](https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html)

- `AOT`: `AOT`是`JDK 9`引入了一种新的编译模式 **`AOT(Ahead of Time Compilation)`**.这种编译模式会在程序被执行前就将其编译成机器码,属于静态编译(`C`,`C++`,`Rust`,`Go` 等语言就是静态编译).`AOT` 避免了 `JIT` 预热等各方面的开销,可以提高` Java `程序的启动速度,避免预热时间长.并且`AOT `还能减少内存占用和增强 `Java `程序的安全性(`AOT` 编译后的代码不容易被反编译和修改),特别适合云原生场景.
  
  > 可参考阿里文章
  > 
  > - [基于静态编译构建微服务应用](https://mp.weixin.qq.com/s/4haTyXUmh8m-dBQaEzwDJw)
  > 
  > - [走向 Native 化:Spring&Dubbo AOT 技术示例与原理讲解 | Apache Dubbo](https://cn.dubbo.apache.org/zh-cn/blog/2023/06/28/%e8%b5%b0%e5%90%91-native-%e5%8c%96springdubbo-aot-%e6%8a%80%e6%9c%af%e7%a4%ba%e4%be%8b%e4%b8%8e%e5%8e%9f%e7%90%86%e8%ae%b2%e8%a7%a3/)

**两者的区别**

> `AOT`的主要优势在于启动时间,内存占用和打包体积.`JIT`的主要优势在于具备更高的极限处理能力,可以降低请求的最大延迟.

**既然 AOT 这么多优点,那为什么不全部使用这种编译方式呢?**

> `JIT` 与 `AOT`,两者各有优点,只能说 `AOT` 更适合当下的云原生场景,对微服务架构的支持也比较友好.除此之外,`AOT` 编译无法支持`Java` 的一些动态特性,如反射,动态代理,动态加载,`JNI(Java Native Interface)`等.然而,很多框架和库(如 `Spring`,`CGLIB`)都用到了这些特性.如果只使用 `AOT` 编译,那就没办法使用这些框架和库了,或者说需要针对性地去做适配和优化.举个例子,`CGLIB` 动态代理使用的是 `ASM` 技术,而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 `.class` 文件,如果全部使用 `AOT` 提前编译,也就不能使用 `ASM` 技术了.为了支持类似的动态特性,所以选择使用 JIT 即时编译器.

## 6. Oracle JDK vs OpenJDK

2006 年 `SUN` 公司将`Java` 开源,也就有了 `OpenJDK`.2009 年 `Oracle` 收购了 `Sun` 公司,于是自己在 `OpenJDK` 的基础上搞了一个 `Oracle JDK`.`Oracle JDK` 是不开源的,并且刚开始的几个版本(`Java8 ~ Java11`)还会相比于 `OpenJDK `添加一些特有的功能和工具.

其次,对于` Java 7` 而言,`OpenJDK` 和 `Oracle JDK` 是十分接近的. `Oracle JDK` 是基于 `OpenJDK 7` 构建的,只添加了一些小功能,由 `Oracle` 工程师参与维护.

**Oracle JDK 和 OpenJDK 如何选择？**

建议选择 `OpenJDK`或者基于 `OpenJDK` 的发行版,比如 `AWS` 的 [Amazon Corretto](https://aws.amazon.com/cn/corretto/?filtered-posts.sort-by=item.additionalFields.createdDate&filtered-posts.sort-order=desc),阿里巴巴的 [Alibaba Dragonwell](https://www.aliyun.com/product/dragonwell#introduction) ([Github](https://github.com/dragonwell-project)).有兴趣可以看看[GraalVM 中文](https://graalvm.java.net.cn/latest/introduction/).

🌈 拓展一下:

- `BCL` 协议(Oracle Binary Code License Agreement):可以使用 `JDK`(支持商用),但是不能进行修改.
- `OTN` 协议(Oracle Technology Network License Agreement):11 及之后新发布的 `JDK` 用的都是这个协议,可以自己私下用,但是商用需要付费.

## 7. 数据类型

`Java`有8种数据类型,分别为:

- 6种数字类型
  
  - 4种整数: `byte`,`short`,`int`,`long`
  
  - 2种浮点数: `float`,`double`

- 1种字符类型 `char`

- 1种布尔类型 `boolean`

注意: 

- 移位运算不支持浮点数,实际中只支持`int`和`long`,编译器在对`short`,`byte`,`char`类型进行移位前,都会将其转换为`int`类型再操作.

- `String`不是基本类型,`String`是 `Java` 标准库中定义的一个**类**（`java.lang.String`）

这八种基本类型都有对应的包装类分别为:`Byte`,`Short`,`Integer`,`Long`,`Float`,`Double`,`Character`,`Boolean`.

**基本类型和封装类型的区别:**

- 用途: 除了定义一些常量和局部变量之外,我们在其他地方如方法参数,对象属性中和很少会使用基本类型来定义变量.并且,包装类型可用于泛型,但是基本类型不可以.

- 存储方式: 基本类型的局部变量可以存放在`Java`虚拟机栈的局部变量表中,基本数据类型的成员变量(未被`static`修饰)存放在`Java`虚拟机的堆中.包装类型属于对象类型,我们知道几乎所有对象实例都存在于堆中.

- 占用空间: 相比于包装类型(对象类型),基本数据类型占用的空间往往非常小.

- 默认值: 成员变量的包装类型不赋值就是`null`,而基本类型有默认值,且不是null.

- 比较方式: 对于基本类型来说,`==`比较的是值,对于包装类型来说,`==`比较的是对象内存的地址.所有整型包装类对象之间值的比较,全部使用 `equals()` 方法.

**什么说是几乎所有对象实例都存在于堆中呢?** 这是因为 `HotSpot` 虚拟机引入了 `JIT` 优化之后,会对对象进行逃逸分析,如果发现某一个对象并没有逃逸到方法外部,那么就可能通过标量替换来实现栈上分配,而避免堆上分配内存

⚠️ 注意:**基本数据类型存放在栈中是一个常见的误区!** 基本数据类型的存储位置取决于它们的作用域和声明方式/如果它们是局部变量,那么它们会存放在栈中;如果它们是成员变量,那么它们会存放在堆/方法区/元空间中.

### 包装类型的缓存机制了解么?

`Java` 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能.

`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128,127]** 的相应类型的缓存数据,`Character` 创建了数值在 **[0,127]** 范围的缓存数据,`Boolean` 直接返回 `TRUE` or `FALSE`.

对于 `Integer`,可以通过 JVM 参数 `-XX:AutoBoxCacheMax=<size>` 修改缓存上限,但不能修改下限 -128.实际使用时,并不建议设置过大的值,避免浪费内存,甚至是 `OOM`.

对于`Byte`,`Short`,`Long` ,`Character` 没有类似 `-XX:AutoBoxCacheMax` 参数可以修改,因此缓存范围是固定的,无法通过 JVM 参数调整.`Boolean` 则直接返回预定义的 `TRUE` 和 `FALSE` 实例,没有缓存范围的概念.

### 自动装箱与拆箱了解吗?

**什么是自动拆装箱?**

- **装箱**: 将基本类型用它们对应的引用类型包装起来
- **拆箱**: 将包装类型转换为基本数据类型

⚠️注意: **如果频繁拆装箱的话,也会严重影响系统的性能.我们应该尽量避免不必要的拆装箱操作.**

### 为什么浮点数运算的时候会有精度丢失的风险?

这个和计算机保存浮点数的机制有很大关系.我们知道计算机是二进制的,而且计算机在表示一个数字时,宽度是有限的,无限循环的小数存储在计算机时,只能被截断,所以就会导致小数精度发生损失的情况.这也就是解释了为什么浮点数没有办法用二进制精确表示.

`BigDecimal` 可以实现对浮点数的运算.不会造成精度丢失.

### 超过 long 整型的数据应该如何表示?

基本数值类型都有一个表达范围,如果超过这个范围就会有数值溢出的风险.

`BigInteger` 内部使用 `int[]` 数组来存储任意大小的整形数据.

相对于常规整数类型的运算来说,`BigInteger` 运算的效率会相对较低.