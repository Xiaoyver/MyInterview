# Java 序列化

## 什么是序列化和反序列化

- 序列化: 将数据结构或对象转换成可以存储或传输的形式,通常是二进制字节流,也可以是 `JSON` , `XML` 等文本格式
- 反序列化: 将在序列化过程中所产生的数据转换为原始数据结构或者对象的过程

- 常见的应用场景:

  - 对象在进行网络传输(比如远程方法调用 RPC 的时候)之前需要先被序列化,接收到序列化的数据之后需要再进行反序列化.
  - 对象在存入 Redis 前要进行序列化,对象从 Redis 中读取出来需要反序列化.

- 序列化协议对应在 TCP/IP 4 层模型的哪一层?
  ```
      ┌────────────────────────────────────────────────┐
      │                  🟦 应用层                     │_____
      │  为计算机用户提供服务                            │    |
      ├────────────────────────────────────────────────┤    |
      │                  🟦 表示层                     │    |-->> 应用层
      │  数据处理(编解码,加密解密,压缩解压缩)         │    |
      ├────────────────────────────────────────────────┤    |
      │                  🟦 会话层                     │ ___|
      │  管理(建立,维护,重连)应用程序之间的会话        │
      ├────────────────────────────────────────────────┤
      │                  🟥 传输层                     │    |-->> 传输层
      │  为两台主机进程之间的通信提供通用的数据传输服务    │
      ├────────────────────────────────────────────────┤
      │                  🟪 网络层                     │    |-->> 网络层
      │  路由和寻址(决定数据在网络的游走路径)           │
      ├────────────────────────────────────────────────┤
      │                  🟩 数据链路层                 │_____
      │  帧编码和误差纠正控制                           │     |
      ├────────────────────────────────────────────────┤    |-->>网络接口层
      │                  🟩 物理层                     │____|
      │  透明地传送比特流传输                           │
      └────────────────────────────────────────────────┘
  ```

## 常见的序列化协议

> `JDK`自带的序列化方式一般不会用,因为序列化效率低,同时也存在安全问题.
> 一般会用 `JSON` , `XML` 等文本格式进行序列化,也可以用 `Hessian` , `Kryo` , `ProtoBuf` 等二进制格式进行序列化.

### JDK 序列化

`JDK`自带的序列化,只需要实现 `java.io.Serializable` 接口即可.

序列化号 `serialVersionUID` 属于版本控制的作用.

如果类的 `serialVersionUID` 与序列化时的 `serialVersionUID` 不一致,则会抛出 `InvalidClassException` 异常.强烈推荐在类中显示地定义 `serialVersionUID`, 如果没有显示定义,编译器会动态生成一个 `serialVersionUID`.

对于不想进行序列化的变量,可以使用 `transient` 关键字修饰.

### Kryo 序列化

`Kryo` 是一个高性能的序列化/反序列化工具,由于其变长存储特性并使用了字节码生成机制,拥有较高的运行速度和较小的字节码体积.

另外,`Kryo`已经是一种非常成熟的序列化实现了,已经在`Twitter`,`Groupon`,`Yahoo`以及多个著名开源项目(如`Hive`,`Storm`)中广泛的使用.

### Protobuf 序列化

`Protobuf` 是 `Google` 开发的一种二进制序列化协议, 它的设计目标是提供一种高效,可扩展的序列化机制, 用于在不同的系统之间进行数据交换.

官方支持 `Java`,`C++`,`Python`,`Go` 等多种语言,通过`.proto`文件定义数据结构,再生成对应语言的代码.

序列化后的数据体积小,解析速度快,优于 `JSON`,`XML` 等文本格式.

### ProtoStuff 序列化

`ProtoStuff` 是 `Protobuf` 的一个实现, 它的设计目标是提供一种高效,可扩展的序列化机制, 用于在不同的系统之间进行数据交换.

`ProtoStuff`专为 `Java` 设计,无需预编译步骤,可直接通过 `POJO` 类进行序列化.不需要 `.proto` 文件,通过反射或预先生成的 `Schema` 实现序列化,使用更灵活.

### Hessian 序列化

`Hessian` 是一个基于二进制的序列化协议,由 `Caucho` 公司开发.它的设计目标是提供一种高效,可扩展的序列化机制,用于在不同的系统之间进行数据交换.

`Hessian` 序列化后的字节流长度较短,解析速度快,同时支持 `Java` 中的所有数据类型,包括自定义对象.

`Hessian` 序列化协议简单,使用方便,同时也支持通过 `HTTP` 进行传输.

### 总结

**总结对比表**
| 方式 | 跨语言 | 性能(速度/体积) | 易用性 | 版本兼容 | 适用场景 |
|------------|--------|------------------|--------|----------|------------------------------|
| Protobuf | 强 | 极佳 | 中等 | 强 | 多语言 RPC,长期存储 |
| Kryo | 弱(仅 Java) | 最优(Java 环境) | 高 | 弱 | 纯 Java 高性能场景 |
| JSON | 极强 | 中等 | 极高 | 中 | 前后端通信,配置文件 |
| Java 原生 | 无 | 差 | 中 | 弱 | 简单本地存储(不推荐生产) |
| Hessian | 中 | 中 | 高 | 中 | 多语言 RPC(传统框架) |

**选择建议**

- 多语言协作/长期存储 → **Protobuf**
- 纯 `Java` 高性能场景 → **Kryo/ProtoStuff**
- 前后端通信/可读性优先 → **JSON**
- 传统企业级应用 → **XML**(谨慎选择,建议迁移到 `JSON`/`Protobuf`)

根据场景优先级(性能,跨语言,可读性)权衡选择,避免过度优化或忽视兼容性.
