# Java 中的BigDecimal

## 介绍

`BigDecimal` 可以实现对小数的运算,不会造成精度的丢失.

通常情况下,大部分需要小数精确运算结果的业务场景(金融场景)都是通过 `BigDecimal` 来实现的.

*为什么浮点数 `float` 或 `double` 运算的时候会有精度丢失的风险呢?*.

> 这个和计算机保存小数的机制有很大关系。
> >
> 我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。
> 
> 这也就是解释了为什么十进制小数没有办法用二进制精确表示。

`BigDecimal` 的实现利用到了 `BigInteger` (用来操作大整数) , 所不同的是 `BigDecimal` 加入了小数位的概念.

**注意**

- `BigDecimal` 等值比较问题
  >
  > `BigDecimal` 使用 `equals()` 方法进行等值比较出现问题的代码示例:
  > 
  > ```java
  > BigDecimal a = new BigDecimal("1");
  > BigDecimal b = new BigDecimal("1.0");
  > System.out.println(a.equals(b));// -->> false
  > ```
  > 
  > 这是因为 `equals()` 方法不仅仅会比较值的大小(value)还会比较精度(scale),而 `compareTo()` 方法比较的时候会忽略精度.
  > 
  > 所以,在使用 `BigDecimal` 进行等值比较时,应该使用 `compareTo()` 方法.
  > 
  > ```java
  > System.out.println(a.compareTo(b) == 0);// -->> true
  > ```

## BigInteger

> `long`是 64 位基本类型,最大值为9223372036854775807(约 9e18),无法存储超过此范围的整数;
>
> 而 `BigInteger` 通过动态数组存储数值,支持任意长度整数,无大小限制(仅受内存影响).

- `BigInteger` 的底层是如何存储数值的
  >
  > `BigInteger` 的底层是通过一个 `int` 数组来存储数值的.
  >
  > 每个数组元素存储 31 位二进制数, 数组长度根据数值的位数动态调整.
  >
- `BigInteger` 是不可变类
  >
  > `BigInteger` 是不可变类, 这意味着一旦创建了 `BigInteger` 对象, 就不能修改它的值.
  >
  > 所有的操作都返回一个新的 `BigInteger` 对象, 而不是修改原始对象.
  >
  > 这是为了确保 `BigInteger` 的线程安全和不可变性.