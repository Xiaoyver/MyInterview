# Java 反射机制

>Java 反射是一种Java语言的特性,它允许在运行时动态地获取类的信息,并可以操作类的属性、方法和构造器等


- 优点
  - 灵活性和动态性: 反射允许程序在运行时动态地获取类的信息,加载类,创建对象,并可以操作其属性、方法和构造器等.显著的提高了程序的灵活性和动态性.
  - 框架开发的基础: 许多`Java`框架(如`Spring`)都使用了反射机制,反射机制为框架的开发提供了基础.
  - 解耦合和通用性: 通过反射可以编写更加通用,高度解耦合的代码,降低模块之间的依赖度.例如通过反射实现的对象拷贝,序列化,Bean工具类等.
- 缺点
  - 性能开销: 反射操作通常比直接调用方法或访问属性要慢,因为反射需要在运行时动态地获取类的信息,并进行方法调用或属性访问.对于大多数框架场景,这种性能损耗通常是可以接受的,或者框架本身会做一些缓存优化.
  - 安全问题: 反射可以绕过`Java`的访问权限检查,如果使用不当,可能会导致安全问题.
  - 代码可读性差: 由于反射操作是在运行时进行的,因此代码的可读性会下降,尤其是在使用反射调用方法或访问属性时.

**应用场景**

我们日常开发中很少会用到反射.但是我们日常用的框架(`Spring`,`Mybatis`)中在底层就大量使用了反射机制.

- `Spring`的依赖注入(`DI`): `Spring`通过反射机制,可以在运行时动态地创建对象,并将对象的依赖关系注入到对象中.
- `Spring`的`AOP`(面向切面编程): `Spring`通过反射机制,可以在运行时动态地创建代理对象,并将横切关注点(如日志、事务等)织入到目标对象中.
- `Spring`的`Bean`工具类: `Spring`提供了`BeanUtils`类,可以通过反射机制,实现对象的拷贝、序列化、反序列化等操作.
- `Mybatis`的`Mapper`接口: `Mybatis`通过反射机制,可以在运行时动态地创建`Mapper`接口的代理对象,并将 SQL 语句映射到方法调用上.

## 获取 Class 对象的四种方式

- 知道具体类的情况下可以使用(用得少)

    ```java
    Class alunbarClass = TargetObject.class;
    ```

- 通过 `Class.forName()`传入类的全路径获取

    ```java
    Class alunbarClass = Class.forName("com.alunbar.TargetObject");
    ```

- 通过对象实例`instance.getClass()`获取

    ```java
    TargetObject targetObject = new TargetObject();
    Class alunbarClass = targetObject.getClass();
    ```

- 通过类加载器`xxxClassLoader.loadClass()`传入类路径获取.

    ```java
    ClassLoader.getSystemClassLoader().loadClass("cn.javaguide.TargetObject");
    ```
