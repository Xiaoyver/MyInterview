# Java 代理模式

> 定义: 为其他对象提供一种代理以控制对这个对象的访问

## 静态代理

静态代理中,我们对目标对象的每个方法的增强都是手动完成的(后面会具体演示代码),非常不灵活(比如接口一旦新增加方法,目标对象和代理对象都要进行修改)且麻烦(需要对每个目标类都单独写一个代理类). 实际应用场景非常非常少,日常开发几乎看不到使用静态代理的场景.

以租房为例,我们一般用租房软件,找中介或者找房东.这里的中介就是代理者.

首先定义一个提供了租房方法的接口.

```java
public interface IRentHouse {
    void rentHouse();
}
```

定义租房的实现类

```java
public class RentHouse implements IRentHouse {
    @Override
    public void rentHouse() {
        System.out.println("租了一间房子...");
    }
}
```

我要租房,房源都在中介手中,所以找中介

```java
public class IntermediaryProxy implements IRentHouse {

    private IRentHouse rentHouse;

    public IntermediaryProxy(IRentHouse irentHouse){
        rentHouse = irentHouse;
    }

    @Override
    public void rentHouse() {
        System.out.println("交中介费");
        rentHouse.rentHouse();
        System.out.println("中介负责维修管理");
    }
}
```

这里中介也实现了租房的接口.

再 `main` 方法中测试

```java
public class Main {

    public static void main(String[] args){
        //定义租房
        IRentHouse rentHouse = new RentHouse();
        //定义中介
        IRentHouse intermediary = new IntermediaryProxy(rentHouse);
        //中介租房
        intermediary.rentHouse();
    }
}
```

> 返回信息
>
> 交中介费
>
> 租了一间房子...
>
> 中介负责维修管理

## 动态代理

从 `JVM` 角度来说,动态代理是在运行时动态生成类字节码,并加载到 `JVM` 中的.

动态代理在我们日常开发中使用的相对较少,但是在框架中的几乎是必用的一门技术.学会了动态代理之后,对于我们理解和学习各种框架的原理也非常有帮助.

### JDK 动态代理机制

#### 介绍

在 `Java` 动态代理机制中 `InvocationHandler` 接口和 `Proxy` 类是核心.

`Proxy` 类中使用频率最高的方法是：`newProxyInstance()` ,这个方法主要用来生成一个代理对象.

```java
public static Object newProxyInstance(ClassLoader loader,
                                      Class<?>[] interfaces,
                                      InvocationHandler h)
    throws IllegalArgumentException
{
    ......
}
```

这个方法一共有 3 个参数：

- `loader` :类加载器,用于加载代理对象.
- `interfaces` : 被代理类实现的一些接口;
- `h` : 实现了 `InvocationHandler` 接口的对象;

要实现动态代理的话,还必须需要实现`InvocationHandler` 来自定义处理逻辑. 当我们的动态代理对象调用一个方法时,这个方法的调用就会被转发到实现`InvocationHandler` 接口类的 `invoke` 方法来调用.

```java
public interface InvocationHandler {

    /**
     * 当你使用代理对象调用方法的时候实际会调用到这个方法
     */
    public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable;
}
```

`invoke()` 方法有下面三个参数：

- `proxy` :动态生成的代理类
- `method` : 与代理类对象调用的方法相对应
- `args` : 当前 `method` 方法的参数

`也就是说：你通过Proxy` 类的 `newProxyInstance()` 创建的代理对象在调用方法的时候,实际会调用到实现 `InvocationHandler` 接口的类的 `invoke()`方法. 你可以在 `invoke()` 方法中自定义处理逻辑,比如在方法执行前后做什么事情.

#### JDK 动态代理类使用步骤

- 定义一个接口及其实现类;
- 自定义 `InvocationHandler` 并重写`invoke`方法,在 `invoke` 方法中我们会调用原生方法(被代理类的方法)并自定义一些处理逻辑;
- 通过 `Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h) `方法创建代理对象;

**代码示例**

1. 定义租房方法的接口.

   ```java
   public interface IRentHouse {
       void rentHouse();
   }
   ```

2. 实现租房的接口

   ```java
   public class RentHouse implements IRentHouse {
       @Override
       public void rentHouse() {
           System.out.println("租了一间房子...");
       }
   }
   ```

3. 定义一个 `JDK` 动态代理类

   `invoke()` 方法: 当我们的动态代理对象调用原生方法的时候,最终实际上调用到的是 `invoke()` 方法,然后 `invoke()` 方法代替我们去调用了被代理对象的原生方法.

   ```java
   public class JdkProxy implements InvocationHandler {
       // 被代理的对象
       private final  Object target;
       public JdkProxy(Object target){
           this.target = target;
       }
       @Override
       public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
           System.out.println("JdkProxy 动态代理");
            //调用方法之前,我们可以添加自己的操作
           System.out.println("before method " + method.getName());
           // 执行目标对象的方法
           Object result = method.invoke(target, args);
           //调用方法之后,我们同样可以添加自己的操作
           System.out.println("after method " + method.getName());
           return result;
       }
   }
   ```

4. 获取代理对象的工厂类

   `getProxy()`：主要通过 `Proxy.newProxyInstance()` 方法获取某个类的代理对象

   ```java
   public class ProxyFactory {
       public static Object getProxy(Object target){
           return Proxy.newProxyInstance(
               target.getClass().getClassLoader(),  // 目标类的类加载
               target.getClass().getInterfaces(), // 代理需要实现的接口,可指定多个
               new JdkProxy(target) // 代理对象关联的调用处理程序
           );
       }
   }
   ```

5. 实际使用

   ```java
   public class Main {
       public static void main(String[] args){
           //定义租房
           IRentHouse rentHouse = new RentHouse();
           //获取代理对象
           IRentHouse proxy = (IRentHouse) ProxyFactory.getProxy(rentHouse);
           //代理对象租房
           proxy.rentHouse();
       }
   }
   ```

   > 返回信息
   >
   > JdkProxy 动态代理
   >
   > before method rentHouse
   >
   > 租了一间房子...
   >
   > after method rentHouse

### CGLIB 动态代理机制

#### 介绍

`JDK` 动态代理有一个最致命的问题是其只能代理实现了接口的类.

为了解决这个问题,我们可以用 `CGLIB` 动态代理机制来避免.

`CGLIB(Code Generation Library)`是一个基于`ASM`的字节码生成库,它允许我们在运行时对字节码进行修改和动态生成.`CGLIB` 通过继承方式实现代理.很多知名的开源框架都使用到了`CGLIB`, 例如 `Spring` 中的 `AOP` 模块中：如果目标对象实现了接口,则默认采用 `JDK` 动态代理,否则采用 `CGLIB` 动态代理.在 `CGLIB` 动态代理机制中 `MethodInterceptor` 接口和 `Enhancer` 类是核心.你需要自定义 `MethodInterceptor` 并重写 `intercept` 方法,i`ntercept` 用于拦截增强被代理类的方法.

```java
public interface MethodInterceptor extends Callback {
    /**
     * 拦截被代理类中的方法调用
     * @param obj 被代理的对象
     * @param method 被拦截的方法
     * @param objects 方法入参
     * @param methodProxy 方法代理类,用于调用原始方法
     * @return 方法执行结果
     */
    Object intercept(Object obj, Method method, Object[] args, MethodProxy methodProxy) throws Throwable;
}
```

#### CGLIB 动态代理类使用步骤

- 定义一个类;
- 自定义 `MethodInterceptor` 并重写 `intercept` 方法,`intercept` 用于拦截增强被代理类的方法,和 `JDK` 动态代理中的 `invoke` 方法类似;
- 通过 `Enhancer` 类的` create()`创建代理类;

**代码示例**

不同于 `JDK` 动态代理不需要额外的依赖.`CGLIB(Code Generation Library)` 实际是属于一个开源项目,如果你要使用它的话,需要手动添加相关依赖

```xml
<dependency>
    <groupId>cglib</groupId>
    <artifactId>cglib</artifactId>
    <version>3.3.0</version>
</dependency>
```

1. 定义租房方法的接口.

   ```java
   public interface IRentHouse {
       void rentHouse();
   }
   ```

2. 实现租房的接口

   ```java
   public class RentHouse implements IRentHouse {
       @Override
       public void rentHouse() {
           System.out.println("租了一间房子...");
       }
   }
   ```

3. 自定义 `MethodInterceptor` (方法拦截器)

   ```java
   public class CglibProxy implements MethodInterceptor {
       @Override
       public Object intercept(Object obj, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
           System.out.println("CglibProxy 动态代理");
           //调用方法之前,我们可以添加自己的操作
           System.out.println("before method " + method.getName());
           // 执行目标对象的方法
           Object result = methodProxy.invokeSuper(obj, args);
           //调用方法之后,我们同样可以添加自己的操作
           System.out.println("after method " + method.getName());
           return result;
       }
   }
   ```

4. 获取代理对象的工厂类

   ```java
   public class ProxyFactory {
       public static Object getProxy(Object target){
           //// 创建动态代理增强类
           Enhancer enhancer = new Enhancer();
           // 设置类加载器
           enhancer.setClassLoader(target.getClass().getClassLoader());
           // 设置被代理类
           enhancer.setSuperclass(target.getClass());
           // 设置回调函数
           enhancer.setCallback(new CglibProxy());
           // 创建代理类
           return enhancer.create();
       }
   }
   ```

5. 实际使用

   ```java
   public class Main {
       public static void main(String[] args){
           //定义租房
           IRentHouse rentHouse = new RentHouse();
           //获取代理对象
           IRentHouse proxy = (IRentHouse) ProxyFactory.getProxy(rentHouse);
           //代理对象租房
           proxy.rentHouse();
       }
   }
   ```

   > 返回信息
   >
   > CglibProxy 动态代理
   >
   > before method rentHouse
   >
   > 租了一间房子...
   >
   > after method rentHouse

### JDK 动态代理和 CGLIB 动态代理对比

- `JDK` 动态代理只能代理实现了接口的类或者直接代理接口,而 `CGLIB` 可以代理未实现任何接口的类. 另外, `CGLIB` 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用,因此不能代理声明为 `final` 类型的类和方法,`private` 方法也无法代理.

- 就二者的效率来说,大部分情况都是 `JDK` 动态代理更优秀,随着 `JDK` 版本的升级,这个优势更加明显.

## 静态代理和动态代理的对比

- 灵活性：动态代理更加灵活,不需要必须实现接口,可以直接代理实现类,并且可以不需要针对每个目标类都创建一个代理类.另外,静态代理中,接口一旦新增加方法,目标对象和代理对象都要进行修改,这是非常麻烦的！
- `JVM` 层面：静态代理在编译时就将接口,实现类,代理类这些都变成了一个个实际的 `class` 文件.而动态代理是在运行时动态生成类字节码,并加载到 `JVM` 中的.
